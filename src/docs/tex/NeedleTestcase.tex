%!TEX root = NeedleReference.tex
\chapter{Needle Testcase}

\section{ObjectUnderTest instantiation and initialization}
\label{sec: ObjectUnderTest}

Needle automatically instantiates all objects under test. The Needle test case analyzes all fields of the test class and thus creates a completely initialized instance.
Multiple fields can be annotated with the @ObjectUnderTest annotation. The annotation can optionally be configured with the implementation of the type and an id.
The id may be used for additional injections. When an object under test is already instantiated, only the dependency injection will be done.


\section{Injection}
\label{sec:Injection}

Needle supports field, constructor and method injection by processing @EJB, @Resource, @PersistenceContext, @PersistenceUnit
and @Inject annotations, if the annotation is available in the classpath of the test execution. By default, Mock objects are created and injected.

The injected objects can be accessed via the API.

\begin{lstlisting}[language={JAVA},caption=Injected Components]
UserDao injectedUserDao = needleRule.getInjectedObject(UserDao.class);
\end{lstlisting}

The key is generated from the respective injection provider. By default, the class object of the associated injection point is used as the key or
-- in the case of resource injection -- the mapped name of the resource.


\section{Custom injection provider}
\label{sec:Custom injection provider}

Needle is extensible by implementing own injection providers or by registering additional annotations.

The following example shows the registration of additional annotations. Needle generates a DefaultMockProvider for each annotation.

\begin{lstlisting}[language={JAVA},caption=Additional Annotation]
custom.injection.annotations=org.jboss.seam.annotations.In, org.jboss.seam.annotations.Logger
\end{lstlisting}

It is also possible to implement own providers. A custom injection provider must implement the de.akquinet.jbosscc.needle.injection.InjectionProvider interface.

\begin{lstlisting}[language={JAVA},caption=javax.inject.Qualifier Injection Provider]

public class CurrentUserInjectionProvider implements InjectionProvider<User> {

   private final User currentUser = new User();

   @Override
   public User getInjectedObject(Class<?> injectionPointType) {
      return currentUser;
   }

   @Override
   public boolean verify(InjectionTargetInformation information) {
      return information.isAnnotationPresent(CurrentUser.class);
   }

   @Override
   public Object getKey(InjectionTargetInformation information) {
      return CurrentUser.class;
   }

}
\end{lstlisting}

A custom injection provider can be provided for a specific test or as a global provider.

\begin{lstlisting}[language={JAVA},caption=Custom injection provider for a specific test]
@Rule
public NeedleRule needleRule = new NeedleRule(new CurrentUserInjectionProvider());
\end{lstlisting}


\begin{lstlisting}[language={JAVA},caption=Global custom injection provider]
custom.injection.provider.classes=de.akquinet.CurrentUserInjectionProvider
\end{lstlisting}


\section{Wiring of object graphs}
\label{sec:Wiring of object graphs}

Sometimes it is necessary to provide own objects as dependencies or wiring complex object graphs.
The object referenced by the field annotated with @InjectIntoMany is injected into all objects referenced by the field annotated with @ObjectUnderTest.
The target field is automatically determined by the type.

\begin{lstlisting}[language={JAVA},caption=InjectIntoMany]
@ObjectUnderTest
private Authenticator authenticator;

@InjectIntoMany
@ObjectUnderTest
private UserDao userDao;
\end{lstlisting}

If the referenced object shall be injected into a specific instance, the field can be annotated using @InjectInto with the ID of the target object.
The target property is automatically determined by the type or can be specified by the field name of the target object with the annotation's fieldName attribute.

\begin{lstlisting}[language={JAVA},caption=InjectInto]
@ObjectUnderTest
private Authenticator authenticator;

@InjectInto(targetComponentId="authenticator")
@ObjectUnderTest
private UserDao userDao;
\end{lstlisting}





