%!TEX root = NeedleReference.tex
\chapter{Database Testing}

\section{Database Testcase}

When unit-testing your application, it is usually recommended to mock out database access (i.e. use mock objects for JPA EntityManagers or DAOs). But sometimes you might like to test against a real database, e.g. to make sure that your queries work as expected. 

In these cases, Needle automatically creates and injects the EntitiyManager instance into your objects under test. You simply need to provide a JPA persistence.xml and the JDBC driver to the classpath of the test execution. The persistence.xml file is the standard configuration file in JPA. The persistence.xml file must define a persistence-unit with a unique name and the transaction type RESOURCE\_LOCAL for a Java SE environment. 

The following listing below shows a complete example of a persistence.xml file. 

\begin{lstlisting}[caption=test persistence.xml]
<?xml version="1.0" encoding="UTF-8" ?>
<persistence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
   version="2.0" xmlns="http://java.sun.com/xml/ns/persistence">
   <persistence-unit name="TestDataModel"
      transaction-type="RESOURCE_LOCAL">

      <class>de.akquinet.jbosscc.needle.example.User</class>
      <class>de.akquinet.jbosscc.needle.example.Profile</class>

      <properties>
         <property name="javax.persistence.jdbc.driver" value="org.hsqldb.jdbcDriver" />
         <property name="javax.persistence.jdbc.url" value="jdbc:hsqldb:." />
         <property name="javax.persistence.jdbc.user" value="sa" />
         <property name="javax.persistence.jdbc.password" value="" />

         <!-- EclipseLink should create the database schema automatically -->
         <property name="eclipselink.ddl-generation" value="create-tables" />
         <property name="eclipselink.ddl-generation.output-mode"
            value="database" />
      </properties>

   </persistence-unit>
</persistence>
\end{lstlisting}

The UserTest below checks the JPA mapping against a real database.

\begin{lstlisting}[language={JAVA},caption=User persistence test]
public class UserTest {

   @Rule
   public DatabaseRule databaseRule = new DatabaseRule();

   @Test
   public void testPersist() throws Exception {

      EntityManager entityManager = databaseRule.getEntityManager();

      User user = new UserTestdataBuilder(entityManager).buildAndSave();

      User userFromDb = entityManager.find(User.class, user.getId());
      Assert.assertEquals(user.getId(), userFromDb.getId());
   }
}
\end{lstlisting}

\section{Transaction utilities}

The EntityManager is the primary interface used by application developers to interact with the underlying database. Many operations must be executed in a transaction.
The TransactionHelper Utility class manage transactions conveniently.

\begin{lstlisting}[language={JAVA},caption=Transaction utilities]
public class UserTest {

   @Rule
   public DatabaseRule databaseRule = new DatabaseRule();
   
   private TransactionHelper transactionHelper = databaseRule.getTransactionHelper();

   @Test
   public void testPersist() throws Exception {

      final User user = new User();
      
      ...
      
      transactionHelper.executeInTransaction(new VoidRunnable() {
         @Override
         public void doRun(EntityManager entityManager) throws Exception {
            entityManager.persist(user);
         }
      });
      
      ...
      
   }
}
\end{lstlisting}

The above example illustrates the use of the TransactionHelper class and the execution of a transaction. The implementation of the VoidRunnable is executed within a transaction.

\section{Database operation}

One common issue in unit tests that access a real database is their affect on the state of the persistence store. Even when you are using a development database, changes to the state may affect future tests. For that, optional Database operations can be executed before and after test execution. 

There are two implementations:
\begin{enumerate}
\item de.akquinet.jbosscc.needle.db.operation.ExecuteScriptOperation \\ Execute sql scripts during test setup and tear down. A before.sql and after.sql script must be provided to the classpath.
\item de.akquinet.jbosscc.needle.db.operation.hsql.HSQLDeleteOperation \\ Deletes all rows of all tables of the hsql database.
\end{enumerate}

To use own Database operation implementations, the abstract base class de.akquinet.jbosscc.needle.db.operation.AbstractDBOperation must be implemented and configured in the needle.properties file.


\section{Testdatabuilder}

With the Test Data Builder pattern, the class that is responsible for creating the test objects provides methods that can be used to configure the test objects. Properties that are not configured use default values. The builder methods can be chained together and provide transient or persistent testdata for the test case.

For this purpose Needle provides an abstract base class. The following code examples shows two implementations of Test Data Builder pattern. The Testdatabuilder inherit from 
de.akquinet.jbosscc.needle.db.testdata.\-AbstractTestdataBuilder class. 

\begin{lstlisting}[language={JAVA},caption=User Testdatabuilder]
public class UserTestdataBuilder extends AbstractTestdataBuilder<User> {

   private String withUsername;
   private String withPassword;
   private Profile withProfile;

   public UserTestdataBuilder() {
      super();
   }

   public UserTestdataBuilder(EntityManager entityManager) {
      super(entityManager);
   }

   public UserTestdataBuilder withUsername(final String username) {
      this.withUsername = username;
      return this;
   }

   private String getUsername() {
      return withUsername != null ? withUsername : "username";
   }

   public UserTestdataBuilder withPassword(final String password) {
      this.withPassword = password;
      return this;
   }

   private String getPassword() {
      return withPassword != null ? withPassword : "password";
   }

   public UserTestdataBuilder withProfile(final Profile profile) {
      this.withProfile = profile;
      return this;
   }

   private Profile getProfile() {
      if (withProfile != null) {
         return withProfile;
      }

      return hasEntityManager() ? new ProfileTestdataBuilder(
            getEntityManager()).buildAndSave()
            : new ProfileTestdataBuilder().build();

   }

   @Override
   public User build() {
      User user = new User();
      user.setUsername(getUsername());
      user.setPassword(getPassword());
      user.setProfile(getProfile());
      return user;
   }

}
\end{lstlisting}

\begin{lstlisting}[language={JAVA},caption=Profile Testdatabuilder]

public class ProfileTestdataBuilder extends AbstractTestdataBuilder<Profile> {

   private String withLanguage;
   
   public ProfileTestdataBuilder() {
      super();
   }

   public ProfileTestdataBuilder(EntityManager entityManager) {
      super(entityManager);
   }


   public ProfileTestdataBuilder withLanguage(final String language) {
      this.withLanguage = language;
      return this;
   }

   private String getLanguage() {
      return withLanguage != null ? withLanguage : "de";
   }

   @Override
   public Profile build() {
      Profile profile = new Profile();
      profile.setLanguage(getLanguage());
      return profile;
   }
}
\end{lstlisting}

In the test cases the implemented Testdatabuilder can produce transient or persisted objects that satisfies the constraints. In the example the Testdatabuilder is using defaults for everything except the username.

\begin{lstlisting}[language={JAVA},caption=Build an persistent User object]
final User user = new UserTestdataBuilder(databaseRule.getEntityManager()).withUsername("user").buildAndSave();
\end{lstlisting}

\begin{lstlisting}[language={JAVA},caption=Build an transient User object]
final User user = new UserTestdataBuilder().withUsername("user").build()
\end{lstlisting}
